[{"title":"投资中的概念名词","path":"/2025/03/16/投资中的概念名词/","content":"非对称风险潜在损失和潜在收益之间的不平衡。 高收益通常伴随高风险，但高风险未必带来高收益；杠杆能放大收益，但也会加剧损失，需谨慎使用；","tags":["Hexo"],"categories":["Life"]},{"title":"基金投资2503","path":"/2025/03/16/基金投资2503/","content":"1. 趋势判断和短期交易在上涨趋势中可以短期交易，过2天就买入卖出，在其他趋势中，短期交易很容易亏钱。 2. 仓位管理要有仓位的概念。比如，只有在自己认为非常低位的情况下，才可以满仓。不然，等出现更好的低位时，没有资金投入了。 仓位建议：假设有20万资金，平时最多只放进去10万。下跌时，就买入一部分，等跌到上证3000以下，可以慢慢满仓（毕竟2800也不是没有发生过，但这种机会几年才能遇到一次）。 预期高点：比如4000点。到这个位置后，就全部卖出。 3. 对称交易策略与交易一致性“对称交易策略”或“交易一致性”强调，投资者进入市场的原因和条件，也应该是他们退出市场的原因和条件。这种方法强调一致性和纪律性，确保交易决策不受情绪或外部噪音的影响。 长期持有：未来看好国家发展和股市，就要一直持有，不要轻易听信一些人云亦云的话，网上说什么的都有。 4. 认知与收益只能赚到自己认知以内的钱。即概率论中的“大数定律”，当交易次数足够多时，人的胜率就会收敛于一个自己认知决定的概率。 5. 逆向投资策略“别人贪婪我恐惧，别人恐惧我贪婪”是反人性的。大家都在赚钱的时候，就是高点，这时候要退出；大家都亏钱的时候，就是低点，这时候要买入。 常见误区：为什么大多数人买股票都是亏的？一个原因是：大多数人入场的时候，都是股市涨到了高点的时候。这时候的股票已经很贵了，入场很难赚到钱，之后就是下跌行情。 正确做法：应该在股票便宜的时候入场，即：当听到周围炒股的朋友说自己亏了很多钱时，这是最佳入场时机。6. 风险与收益收益高的都是高风险的，不可能既有高收益，又有低风险 7. 见好就收3月初，上涨到最高点的时候，总觉得第二天还会涨，不仅没想着卖掉，还想着加仓，结果之后一周一直在跌，结果收益跌没了，跌的比赚的多。在大跌到低点附近的时候，没有及时加仓，因为担心明天还会跌，不敢加仓，导致错过了低位买入的时机。 如果见好就收，之前的利润可以到手，而且到低点的时候，还可以低位买入。 如何见好就收？将要投资的资金分为3份，1份作为长期持有；1份用于短期交易，1份用于抄底或底牌；在快到达近2周的高点的时候，就卖出短期交易的1份；如果认为接下来是牛市，就一直持有长期持有的1份；当有重大利好，或其他机会，再使用用于抄底的1份。","tags":["Hexo"],"categories":["基金"]},{"title":"arch升级问题","path":"/2025/03/15/arch升级问题/","content":"长期没有使用的arch系统的电脑，升级报错。 pacman -Syyu 更新时，提示glibc版本过低，需要2.38版本，所有的都无法升级 12pacman: /usr/lib/libc.so.6: version `GLIBC_2.38&#x27; not found (required by pacman)pacman: /usr/lib/libc.so.6: version `GLIBC_2.38&#x27; not found (required by /usr/lib/libalpm.so.15) 失败的尝试：到镜像仓库，手动下载后，pacman -U 安装，仍然提示glibc问题 解决方式： 打开 https://aur.archlinux.org/packages/pacman-static 找到置顶评论，下载一个二进制包https://pkgbuild.com/~morganamilo/pacman-static/x86_64/bin/下载好这个包之后，直接 chmod +x pacman-static 最后执行下面的命令安装缺失的 glibc 1./pacman-static -S glibc 但是提示秘钥检查错误 is unknown trust 解决方式：直接临时禁用，到/etc/pacman.conf 设置 SigLevel = Never，然后重试即可 之后去掉禁用，重新设置秘钥 123sudo pacman-key --initsudo pacman-key --populate archlinuxsudo pacman-key --refresh-keys 之后正常安装即可","tags":["arch"],"categories":["environment"]},{"title":"一些工具","path":"/2022/07/21/一些工具/","content":"win上的免费剪切板工具： Ditto","tags":["Hexo"],"categories":["Life"]},{"title":"WebAssembly","path":"/2022/05/28/WebAssembly/","content":"一个WebAssembly例子 1234567891011121314rustc --version 检查是否安装rustup 安装和版本管理工具Cargo：Rust 的构建工具和包管理器rustup update 升级rustcargo new hello 创建项目cargo build 可以构建项目cargo run 可以运行项目cargo test 可以测试项目cargo doc 可以为项目构建文档cargo publish 可以将库发布到 crates.io 更新cargo 源在.cargo/下，创建config文件，配置如下 12345[source.crates-io]registry = &quot;https://github.com/rust-lang/crates.io-index&quot;replace-with = &#x27;ustc&#x27;[source.ustc]registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot; 123456789安装wasm-packsudo curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | shcargo install cargo-generatecargo generate --git https://github.com/rustwasm/wasm-pack-templatewasm-pack build","tags":["Hexo"],"categories":["Life"]},{"title":"使用wsl","path":"/2022/05/28/使用wsl/","content":"windows应用商店下载太慢，更新DNS为4.2.2.1,然后刷新dnsipconfig /flushdns. 准备阶段 12345678910111213141516171819# /etc/apt/source.list 更新源# 安装常用软件apt install net-toolsapt install curl# nodejsapt install nodejsapt install npm npm config set registry http://npmmirror.com # 换个镜像源# gotar -C /usr/local -xzf goxx-amd64.tar.gz# 在/etc/profile中加环境变量export PATH=$PATH:/usr/local/go/binsource /etc/profile# rubysudo apt install rbenvrbenv install --listrbenv install 2.7.1 ruby 1","tags":["Hexo"],"categories":["Life"]},{"title":"flask结合nacos和GraphQL构建微服务","path":"/2020/12/17/flask结合nacos和GraphQL构建微服务/","content":"Flask结合nacos和graphql构建微服务 准备12pip install nacos-sdk-pythonpip install graphene Flask结合graphql12345678910111213141516171819202122232425262728293031323334353637383940414243444546from graphene import ObjectType, Field, String,Int# 自定义的类型class ItemList(ObjectType): class Meta: description = &quot;这是返回类型的注释，要放在Meta类中，graphql会显示&quot; data = List(Item) # list列表，Item是自定义类型 total = Int() # 标量类型 page = Field(PageInfo)\t# PageInfo是自定义类型，自定义类型需要有Field()class Query(ObjectType): hello = Field(Result, user_name=String()) # Result是返回结果，name是参数 itemList = Field(ItemList,a = Int(),b = Int()) # ItemList是返回类型，a和b是传入的参数 def resolve_hello(root, info,user_name): return Result(1,&quot;ok&quot;)\tdef resolve_itemList(root,info,a,b): return ItemList()schema = Schema(query=Query)def create_app(): app = Flask(__name__) app.add_url_rule(&#x27;/graphql&#x27;, view_func=GraphQLView.as_view(&#x27;graphql&#x27;, schema=schema, graphiql=True)) @app.route(&#x27;/hello&#x27;, methods=[&#x27;get&#x27;]) def hello(): # 普通请求 return &quot;hello&quot; return appif __name__ == &#x27;__main__&#x27;: app = create_app() ip = getIp() print(ip) app.run(ip,9099,debug=True) # 用如下方式，如果不想出现WARNING: This is a development server. Do not use it in a production deployment. # server = pywsgi.WSGIServer((ip, 9099), app) # server.serve_forever() # 在ip:9099/graphql下，即可访问# 在graphql中，请求如下#&#123;#\thello(user_name:&quot;tom&quot;)&#123; result &#125;#&#125; 注册服务&amp;维持心跳1234567891011121314151617181920import timeimport nacosimport socketdef getIp(): hostname = socket.gethostname() ip = socket.gethostbyname(hostname) return ipSERVER_ADDRESSES = &quot;1.1.1.1:8848&quot;NAMESPACE = &quot;public&quot;client = nacos.NacosClient(SERVER_ADDRESSES, namespace=NAMESPACE, username=&quot;nacos&quot;, password=&quot;nacos&quot;)# 注册实例client.add_naming_instance(&quot;service-hello&quot;, ip=utils.getIp(), port=&quot;9099&quot;)# 需要不断发送心跳while True: time.sleep(3) client.send_heartbeat(&quot;service-hello&quot;,ip=getIp(),port=&quot;9099&quot;) # 持续发心跳 spring调用python的微服务 12345678910111213141516171819// FeignClient接口@Service@FeignClient(name = &quot;service-hello&quot;)public interface AnormalClient &#123; @PostMapping(value=&quot;/graphql&quot;, consumes= MediaType.APPLICATION_JSON_VALUE) String graphql(String sql); @GetMapping(&quot;/hello&quot;) String hello();&#125;// 调用微服务String name = &quot;tom&quot;;String q = String.format(&quot;&#123; hello(name: &#x27;%s&#x27;)&#123;code &#125;&#125;&quot;,name ).replace(&#x27;\\&#x27;&#x27;,&#x27;&quot;&#x27;);JSONObject jsonObject=new JSONObject();jsonObject.put(&quot;query&quot;,q);System.out.println(jsonObject.toJSONString());String result = anormalClient.graphql(jsonObject.toJSONString());System.out.println(result); 遇到的问题1234567891011There was an unexpected error (type=Internal Server Error, status=500).message&quot;:&quot;Must provide query string.&quot;1 在postman上按照graphql的格式请求可以正常返回结果2 抓包后发现请求是 content-type:text/plain 格式的。3 在postman上按照 content-type:application/json格式请求时，可以正常返回结果。在postman上按照 content-type:text/plain 的格式请求，出现同样错误message&quot;:&quot;Must provide query string&quot;，所以错误原因时请求的content-type格式问题。4 将请求设置为appllication/json格式只需要修改注解即可：consumes指定content-Type格式。@PostMapping(value=&quot;hello&quot;,consumes= MediaType.APPLICATION_JSON_VALUE)测试通过。","tags":["flask","nacos","graphql","微服务"],"categories":["python"]},{"title":"Vim 使用说明","path":"/2020/12/08/Vim-使用说明/","content":"vim两种模式，insert和normal模式，normal就是命令模式，insert就是编辑模式。 参考https://coolshell.cn/articles/5426.html 非常全的：https://vim.rtorr.com/lang/zh_cn 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 插入模式i\t光标前插入a\t光标后插入，appendo\t在当前行后插入一个新行#移动0\t行前^\t本行第一个非空白字符$\t本行最后一个字符/pattern\t搜索pattern，回车后，按n到下一个# 粘贴拷贝dd\t删除当前行，并存入剪切板p 粘贴剪切板yy\t拷贝当前行，等于ddp# 撤回u\tundoctrl+r\tredo# 打开保存退出:e &lt;filename&gt; 打开文件:w\t保存:saveas &lt;name&gt; 另存为:bn\t切换到下一个文件 next:bp\t切换到上一个文件 pre# 高级.\t重复上一次命令N&lt;command&gt;\t重复N次3dd\t删除3行5p\t粘贴5次# 移动:set nu\t显示行gg\t移动到第一行G\t移动到最后一行:12\t移动到第12行w\t下一个单词开头e\t下一个单词结尾，若在当前单词中间，就移动到当前单词结尾b\t当前单词开头%\t在括号上使用，移动到匹配的另一个括号*\t移动到和当前单词相同的下一个单词#\t移动到和当前单词相同的上一个单词&lt;start position&gt;&lt;command&gt;&lt;end position&gt;0y$\t从行开头复制到行结尾ye\t从当前位置拷贝到本单词的最后一个字符yb\t从当前位置前一个次方拷贝到本单词的第一个字符v 进入可视化v 方向键选择，然后y，可以范围复制v 方向键选择，然后d，可以范围删除","tags":["vim"],"categories":["linux"]},{"title":"使用hexo创建github pages","path":"/2020/12/01/hexo创建gitpages/","content":"hexo：一个使用简单的博客框架，通过md文件生成静态页面。Travis CI：持续集成工具，检测到github上的提交后，自动执行脚本，更新静态页面hexo主题：ILS 创建两个分支，main和gp-pages，main存放所有文件，gh-pages存放生成的页面，同时在settings里面将gh-pages设置为github Pages的默认分支。使用时，只需要git上传md文件，travis就会自动执行脚本，更新gh-pages分支内容。 使用12345678910111213141516npm install hexo-cli -gnpm init xxcd xx# 创建$ hexo new &quot;My New Post&quot;# 本地生成$ hexo g # 本地演示$ hexo server# 部署 https://hexo.io/zh-cn/docs/one-command-deployment# 安装hexo-deployer-git后，$ hexo clean $ hexo d 问题12345678push代码后，打开blog页面，发现是一片空白。看gh-pages里面生成的代码，是空的。本地hexo generate是没有问题的。检查main分支的themes下的ils，是空的。且ils文件夹有一个白色箭头，代表一个子模块。重新git add themes/ils，出现错误。fatal: in unpopulated submodule &#x27;themes/ils&#x27;git rm -rf themes/ils删掉ils，再重新添加，解决。","tags":["hexo","git"],"categories":["其他"]}]